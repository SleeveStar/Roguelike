// wfc.js
import { forestTiles, iceTiles, caveTiles, volcanicTiles } from './tiles.js';

/**
 * Automatically calculate tile weights from TILE_PROPERTIES
 */
function buildTileWeights(tileSet) {
    const weights = {};

    for (const tileName of Object.values(tileSet.TILE_TYPES)) {
        const prop = tileSet.TILE_PROPERTIES[tileName];

        let weight = 1;

        if (prop?.walkable) weight *= 10;          // 기본 바닥
        if (!prop?.walkable) weight *= 0.8;        // 장애물
        if (prop?.spawnable === false) weight *= 0.7;

        // 이름 기반 추가 감쇠 (tiles.js 안 건드리기 위함)
        if (tileName.includes('WOOD')) weight *= 0.4;
        if (tileName.includes('ROCK')) weight *= 0.4;
        if (tileName.includes('LAKE')) weight *= 0.25;

        weights[tileName] = weight;
    }

    return weights;
}

/**
 * Weighted random choice
 */
function weightedRandom(options, weights) {
    let total = 0;
    for (const opt of options) total += weights[opt] ?? 1;

    let r = Math.random() * total;
    for (const opt of options) {
        r -= weights[opt] ?? 1;
        if (r <= 0) return opt;
    }
    return options[0];
}

/**
 * Shannon entropy
 */
function entropy(options, weights) {
    let sum = 0;
    let sumLog = 0;

    for (const opt of options) {
        const w = weights[opt] ?? 1;
        sum += w;
        sumLog += w * Math.log(w);
    }

    return Math.log(sum) - (sumLog / sum);
}

export function generateWfcMap(width, height, activeTileSet) {
    const tileSet = activeTileSet;
    const TILE_WEIGHTS = buildTileWeights(tileSet);

    function initGrid() {
        const grid = [];
        const allTiles = Object.values(tileSet.TILE_TYPES);

        for (let y = 0; y < height; y++) {
            grid[y] = [];
            for (let x = 0; x < width; x++) {
                grid[y][x] = {
                    x,
                    y,
                    collapsed: false,
                    options: [...allTiles],
                };
            }
        }
        return grid;
    }

    function lowestEntropyCells(grid) {
        let min = Infinity;
        let cells = [];

        for (const row of grid) {
            for (const cell of row) {
                if (cell.collapsed || cell.options.length === 0) continue;

                const e = entropy(cell.options, TILE_WEIGHTS);
                if (e < min) {
                    min = e;
                    cells = [cell];
                } else if (e === min) {
                    cells.push(cell);
                }
            }
        }
        return cells;
    }

    function propagate(start, grid) {
        const stack = [start];
        const w = grid[0].length;
        const h = grid.length;

        while (stack.length) {
            const cell = stack.pop();
            const { x, y } = cell;

            const neighbors = [
                { dx: 0, dy: -1, dir: 'down' },
                { dx: 1, dy: 0, dir: 'left' },
                { dx: 0, dy: 1, dir: 'up' },
                { dx: -1, dy: 0, dir: 'right' },
            ];

            for (const { dx, dy, dir } of neighbors) {
                const nx = x + dx;
                const ny = y + dy;
                if (nx < 0 || ny < 0 || nx >= w || ny >= h) continue;

                const n = grid[ny][nx];
                if (n.collapsed) continue;

                const before = n.options.length;

                n.options = n.options.filter(opt =>
                    cell.options.some(cOpt =>
                        tileSet.ADJACENCY_RULES[cOpt]?.[dir]?.includes(opt)
                    )
                );

                if (n.options.length < before) {
                    stack.push(n);
                }
            }
        }
    }

    let tries = 0;

    while (tries < 10) {
        const grid = initGrid();
        let done = 0;

        while (done < width * height) {
            const candidates = lowestEntropyCells(grid);
            if (!candidates.length) break;

            const cell = candidates[Math.floor(Math.random() * candidates.length)];
            const choice = weightedRandom(cell.options, TILE_WEIGHTS);

            cell.options = [choice];
            cell.collapsed = true;
            done++;

            propagate(cell, grid);
        }

        if (done === width * height) {
            return grid.map(row =>
                row.map(cell => ({ name: cell.options[0] }))
            );
        }

        tries++;
    }

    console.error('WFC failed');
    return null;
}



** 중요사항 위와같은 방법으로 수정했을때 기대되는 것과 문제가 생길 수도 있는곳을 분석해보도록해 