# 스킬 시스템 도입 상세 계획서 (v6.1)

## 1. 개요

이 문서는 Web Roguelike 프로젝트에 **플레이어의 스킬 트리 시스템**과 **몬스터의 스킬 사용 시스템**을 도입하기 위한 종합 계획을 상세히 기술합니다. **액티브 스킬은 마나(MP)를 소모하며, 그 위력은 시전자의 현재 스탯(능력치)에 비례하여 계산되도록 설계하여 캐릭터 성장, 장비, 패시브 스킬에 따른 스킬 강화 효과가 전투에서 명확히 체감되도록 합니다.**

- **플레이어**:  
  레벨업 시 스킬 포인트를 획득합니다. 스킬 트리는 왼쪽 스테이터스 창의 **‘스킬’ 버튼을 클릭**하여 접근하며, 이곳에서 **‘근접’, ‘마법’, ‘원거리’** 특성으로 나뉜 스킬 트리에서 패시브 또는 액티브 스킬을 배울 수 있습니다.  
  **잔여 스킬 포인트가 있을 경우 ‘스킬’ 버튼이 반짝여** 사용자에게 이를 시각적으로 알립니다.  
  습득한 액티브 스킬은 **드래그 앤 드롭 방식**으로 전투 스킬 슬롯에 장착하여 사용합니다.

- **몬스터**:  
  각 몬스터는 자신의 개성에 맞는 고유 스킬을 보유하며, 전투 중 **낮은 확률 또는 전투 상황에 따른 판단**으로 일반 공격 대신 스킬을 사용합니다.  
  몬스터 스킬 또한 **몬스터의 현재 스탯에 연동되어 위력이 결정**됩니다.

이 계획은 플레이어의 성장 전략, 빌드 다양성, 전투의 긴장감과 예측 불가능성을 극대화하는 것을 목표로 합니다.

---

## 2. 플레이어 스킬 시스템

### 2.1. 데이터 구조 설계

#### A. `skills.js` (신규 생성 및 구조 확장)

플레이어의 스킬 트리를 구성하기 위해 스킬 정의를 구체화합니다.  
모든 액티브 스킬은 **계수(coefficient) 기반 설계**를 적용하여, 공통적인 데미지 계산 구조 안에서 스탯 연동 효과가 일관되게 적용되도록 합니다.

- **플레이어 스킬 예시 (`SKILLS`)**:
```javascript
export const SKILLS = {
    "powerStrike": {
        id: "powerStrike",
        name: "강타",
        type: "active", // 'active' 또는 'passive'
        tree: "melee", // 'melee', 'magic', 'ranged'
        cost: 10, // MP 소모량
        cooldown: 3, // 재사용 대기 턴 수
        dependencies: [],
        position: { x: 0, y: 0 },
        icon: "img/skills/power_strike.png",
        description: "적에게 강력한 물리 피해를 입힙니다.",
        coefficient: 1.5,
        effect: (caster, target) => {
            const damage = caster.derived.physicalAttack * 1.5;
            target.hp -= damage;
            return `${target.name}에게 ${damage.toFixed(0)}의 물리 피해를 입혔다!`;
        }
    },

    "meleeMastery": {
        id: "meleeMastery",
        name: "근접 숙련",
        type: "passive",
        tree: "melee",
        dependencies: ["powerStrike"],
        position: { x: 0, y: 1 },
        icon: "img/skills/melee_mastery.png",
        description: "모든 물리 공격력이 5% 증가합니다.",
        applyOrder: 2,
        effect: (derivedStats) => {
            derivedStats.physicalAttack = Math.floor(
                derivedStats.physicalAttack * 1.05
            );
        }
    },

    "fireball": {
        id: "fireball",
        name: "화염구",
        type: "active",
        tree: "magic",
        cost: 15,
        cooldown: 4,
        dependencies: [],
        position: { x: 0, y: 0 },
        icon: "img/skills/fireball.png",
        description: "적에게 강력한 화염 마법 피해를 입힙니다.",
        coefficient: 1.8,
        effect: (caster, target) => {
            const damage = caster.derived.magicalAttack * 1.8;
            target.hp -= damage;
            return `${target.name}에게 ${damage.toFixed(0)}의 마법 피해를 입혔다!`;
        }
    }
};
```

#### B. `gameState.js` (상태 확장)

- `playerStats.base` 객체에 다음 항목을 추가합니다.
  - `availableSkillPoints`: 레벨업 시 획득하는 스킬 포인트
  - `learnedSkills`: 플레이어가 습득한 스킬 ID 목록
  - `skillSlots`: 전투에서 사용할 액티브 스킬 슬롯 정보

```javascript
skillSlots: {
    max: 4,
    slots: [null, null, null, null]
}
```

- `gameState` 루트에 플레이어 스킬 쿨다운 관리용 객체를 유지합니다.

```javascript
skillCooldowns: {}
```

---

### 2.2. UI 구현

#### A. `index.html` (스킬 트리 모달 및 버튼 추가)

```html
<div class="player-actions">
    <button id="inventoryBtn" class="action-btn">인벤토리</button>
    <button id="skillTreeBtn" class="action-btn">스킬</button>
</div>
```

```html
<div id="skillTreeModal" class="modal hidden">
    <div class="modal-content skill-tree-modal">
        <button id="closeSkillTreeModal" class="close-btn">X</button>
        <h2>
            스킬 트리 (사용 가능 스킬 포인트:
            <span id="skillPointsDisplay">0</span>)
        </h2>
    </div>
</div>
```

#### B. `ui.js` (스킬 트리 및 드래그 앤 드롭 로직)

- `showSkillTreeModal()` : 스킬 트리 모달 표시
- `renderSkillTree()` : 스킬 노드 렌더링
- `renderSkillSlotManagementBar()` : 슬롯 UI 갱신
- 드래그 앤 드롭을 통해 `gameState.skillSlots.slots` 관리

#### C. `style.css` (스킬 버튼 반짝임 애니메이션)

```css
@keyframes blink-animation {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}

#skillTreeBtn.blinking {
    animation: blink-animation 1s infinite;
    border: 2px solid yellow;
    box-shadow: 0 0 10px yellow;
}
```

#### D. `ui.js` (스킬 버튼 상태 갱신)

```javascript
export function updateSkillTreeButtonState() {
    if (skillTreeBtn) {
        if (gameState.playerStats.base.availableSkillPoints > 0) {
            skillTreeBtn.classList.add("blinking");
        } else {
            skillTreeBtn.classList.remove("blinking");
        }
    }
}
```

---

### 2.3. 핵심 로직 구현

#### A. `gameLogic.js` (플레이어 스킬 로직)

- `levelUp()`  
  - 스킬 포인트 1 증가  
  - 스킬 포인트 획득 로그 출력  
  - `updateSkillTreeButtonState()` 호출  

- `learnSkill(skillId)`  
  1. 스킬 데이터 로드  
  2. 스킬 포인트 및 선행 조건 확인  
  3. 스킬 습득 처리  
  4. 패시브 스킬일 경우 `recalculateDerivedStats()` 즉시 호출  
  5. UI 갱신  
  6. 버튼 상태 갱신  

- `useSkill(skillId, target)`  
  1. MP 확인 및 차감  
  2. 쿨다운 확인  
  3. 스킬 효과 적용 (스탯 연동)  
  4. 쿨다운 설정  
  5. 전투 로그 출력  

- `recalculateDerivedStats()`  
  - 기본 스탯 계산  
  - 장비 효과 적용  
  - 패시브 스킬을 `applyOrder` 기준으로 순차 적용  

---

## 3. 몬스터 스킬 시스템

### 3.1. 데이터 구조 설계

#### A. `skills.js` (몬스터 스킬 정의)

```javascript
export const MONSTER_SKILLS = {
    "poisonSpit": {
        id: "poisonSpit",
        name: "독 뱉기",
        cooldown: 4,
        description: "플레이어를 중독시켜 지속 피해를 입힙니다.",
        effect: (caster, target) => {
            applyStatusEffect(target, {
                type: "poison",
                duration: 3,
                magnitude: caster.magicalAttack * 0.5
            });
        }
    },

    "frenzy": {
        id: "frenzy",
        name: "광란",
        cooldown: 5,
        description: "일정 시간 동안 자신의 공격력을 증가시킵니다.",
        effect: (caster) => {
            applyStatusEffect(caster, {
                type: "berserk",
                duration: 3,
                magnitude: 1.5
            });
        }
    }
};
```

#### B. `constants.js` (몬스터-스킬 연결)

```javascript
export const MONSTER_TYPES = [
    { name: "POISON_MUSHMAN", archetype: "caster", biomes: ["FOREST"], skills: ["poisonSpit"] },
    { name: "WEREWOLF", archetype: "bruiser", biomes: ["FOREST"], skills: ["frenzy"] }
];
```

---

### 3.2. 핵심 로직 구현

#### A. `startCombat()`

- 몬스터 스킬 쿨다운 객체 초기화
- `currentCombatMonster.skillCooldowns` 생성

#### B. `monsterTurn()`

1. 상태 이상 처리  
2. 스킬 쿨다운 감소  
3. 스킬 사용 여부 판단  
4. 사용 가능 스킬 필터링  
5. 스킬 또는 일반 공격 실행  

---

## 4. 통합 실행 계획 요약

1. 데이터 구조 정의  
2. UI 요소 및 이벤트 연결  
3. 플레이어 스킬 로직 구현  
4. 몬스터 스킬 로직 구현  
5. 전체 흐름 테스트 및 밸런싱  
