// tiles.js
// Î™®Îì† Î∞îÏù¥Ïò¥ Ï†ïÏùò + Í∞ÄÏ§ëÏπò + Í∑∏Î£π + Ïù∏Ï†ë Í∑úÏπô Ìè¨Ìï®

/* =====================================================
   Í≥µÌÜµ Biome Factory
===================================================== */

function expandRules(groups, rules) {
    const result = {};
    for (const group in rules) {
        result[group] = {};
        for (const dir in rules[group]) {
            result[group][dir] = rules[group][dir]
                .flatMap(g => groups[g]);
        }
    }
    return result;
}

function createBiomeTileSet(tileTypes, tileProps, groups, rawRules) {
    const expanded = expandRules(groups, rawRules);
    const adjacency = {};

    for (const group in expanded) {
        for (const tile of groups[group]) {
            adjacency[tile] = expanded[group];
        }
    }

    return {
        TILE_TYPES: tileTypes,
        TILE_PROPERTIES: tileProps,
        ADJACENCY_RULES: adjacency
    };
}

/* =====================================================
   üå≤ FOREST BIOME
===================================================== */

const FOREST_TILE_TYPES = {
    FIELD: 'forest_field',
    FLOWER: 'forest_flower',
    TREE_1: 'forest_tree_1',
    TREE_2: 'forest_tree_2',
    ROCK: 'forest_rock'
};

const FOREST_TILE_PROPERTIES = {
    [FOREST_TILE_TYPES.FIELD]: { walkable: true, spawnable: true, baseWeight: 14 },
    [FOREST_TILE_TYPES.FLOWER]: { walkable: true, spawnable: true, baseWeight: 4 },
    [FOREST_TILE_TYPES.TREE_1]: {
        walkable: false, spawnable: false, baseWeight: 3,
        weightModifiers: { multiplier: 0.6 }
    },
    [FOREST_TILE_TYPES.TREE_2]: {
        walkable: false, spawnable: false, baseWeight: 2,
        weightModifiers: { multiplier: 0.5 }
    },
    [FOREST_TILE_TYPES.ROCK]: {
        walkable: false, spawnable: false, baseWeight: 1,
        weightModifiers: { multiplier: 0.4 }
    }
};

const FOREST_GROUPS = {
    GROUND: [FOREST_TILE_TYPES.FIELD, FOREST_TILE_TYPES.FLOWER],
    OBSTACLE: [FOREST_TILE_TYPES.TREE_1, FOREST_TILE_TYPES.TREE_2, FOREST_TILE_TYPES.ROCK]
};

const FOREST_RULES = {
    GROUND: { up: ['GROUND','OBSTACLE'], down: ['GROUND','OBSTACLE'], left: ['GROUND','OBSTACLE'], right: ['GROUND','OBSTACLE'] },
    OBSTACLE: { up: ['GROUND'], down: ['GROUND'], left: ['GROUND'], right: ['GROUND'] }
};

export const forestTiles = createBiomeTileSet(
    FOREST_TILE_TYPES,
    FOREST_TILE_PROPERTIES,
    FOREST_GROUPS,
    FOREST_RULES
);

/* =====================================================
   ‚ùÑ ICE BIOME
===================================================== */

const ICE_TILE_TYPES = {
    SNOW: 'ice_snow',
    ICE: 'ice_ice',
    CRACK: 'ice_crack',
    ROCK: 'ice_rock'
};

const ICE_TILE_PROPERTIES = {
    [ICE_TILE_TYPES.SNOW]: { walkable: true, spawnable: true, baseWeight: 10 },
    [ICE_TILE_TYPES.ICE]: { walkable: true, spawnable: true, baseWeight: 6 },
    [ICE_TILE_TYPES.CRACK]: {
        walkable: true, spawnable: false, baseWeight: 2,
        weightModifiers: { multiplier: 0.6 }
    },
    [ICE_TILE_TYPES.ROCK]: {
        walkable: false, spawnable: false, baseWeight: 1,
        weightModifiers: { multiplier: 0.4 }
    }
};

const ICE_GROUPS = {
    GROUND: [ICE_TILE_TYPES.SNOW, ICE_TILE_TYPES.ICE],
    DANGER: [ICE_TILE_TYPES.CRACK],
    OBSTACLE: [ICE_TILE_TYPES.ROCK]
};

const ICE_RULES = {
    GROUND: { up: ['GROUND','DANGER'], down: ['GROUND','DANGER'], left: ['GROUND','DANGER'], right: ['GROUND','DANGER'] },
    DANGER: { up: ['GROUND'], down: ['GROUND'], left: ['GROUND'], right: ['GROUND'] },
    OBSTACLE: { up: ['GROUND'], down: ['GROUND'], left: ['GROUND'], right: ['GROUND'] }
};

export const iceTiles = createBiomeTileSet(
    ICE_TILE_TYPES,
    ICE_TILE_PROPERTIES,
    ICE_GROUPS,
    ICE_RULES
);

/* =====================================================
   üï≥ CAVE BIOME
===================================================== */

const CAVE_TILE_TYPES = {
    FLOOR: 'cave_floor',
    MUD: 'cave_mud',
    ROCK: 'cave_rock',
    PILLAR: 'cave_pillar'
};

const CAVE_TILE_PROPERTIES = {
    [CAVE_TILE_TYPES.FLOOR]: { walkable: true, spawnable: true, baseWeight: 8 },
    [CAVE_TILE_TYPES.MUD]: { walkable: true, spawnable: true, baseWeight: 4 },
    [CAVE_TILE_TYPES.ROCK]: {
        walkable: false, spawnable: false, baseWeight: 3,
        weightModifiers: { multiplier: 0.7 }
    },
    [CAVE_TILE_TYPES.PILLAR]: {
        walkable: false, spawnable: false, baseWeight: 2,
        weightModifiers: { multiplier: 0.5 }
    }
};

const CAVE_GROUPS = {
    GROUND: [CAVE_TILE_TYPES.FLOOR, CAVE_TILE_TYPES.MUD],
    WALL: [CAVE_TILE_TYPES.ROCK, CAVE_TILE_TYPES.PILLAR]
};

const CAVE_RULES = {
    GROUND: { up: ['GROUND','WALL'], down: ['GROUND','WALL'], left: ['GROUND','WALL'], right: ['GROUND','WALL'] },
    WALL: { up: ['GROUND'], down: ['GROUND'], left: ['GROUND'], right: ['GROUND'] }
};

export const caveTiles = createBiomeTileSet(
    CAVE_TILE_TYPES,
    CAVE_TILE_PROPERTIES,
    CAVE_GROUPS,
    CAVE_RULES
);

/* =====================================================
   üåã VOLCANIC BIOME
===================================================== */

const VOLCANIC_TILE_TYPES = {
    ASH: 'volcanic_ash',
    BASALT: 'volcanic_basalt',
    LAVA: 'volcanic_lava',
    ROCK: 'volcanic_rock'
};

const VOLCANIC_TILE_PROPERTIES = {
    [VOLCANIC_TILE_TYPES.ASH]: { walkable: true, spawnable: true, baseWeight: 6 },
    [VOLCANIC_TILE_TYPES.BASALT]: { walkable: true, spawnable: true, baseWeight: 4 },
    [VOLCANIC_TILE_TYPES.LAVA]: {
        walkable: false, spawnable: false, baseWeight: 2,
        weightModifiers: { multiplier: 0.5 }
    },
    [VOLCANIC_TILE_TYPES.ROCK]: {
        walkable: false, spawnable: false, baseWeight: 1,
        weightModifiers: { multiplier: 0.4 }
    }
};

const VOLCANIC_GROUPS = {
    GROUND: [VOLCANIC_TILE_TYPES.ASH, VOLCANIC_TILE_TYPES.BASALT],
    HAZARD: [VOLCANIC_TILE_TYPES.LAVA],
    OBSTACLE: [VOLCANIC_TILE_TYPES.ROCK]
};

const VOLCANIC_RULES = {
    GROUND: { up: ['GROUND','HAZARD'], down: ['GROUND','HAZARD'], left: ['GROUND','HAZARD'], right: ['GROUND','HAZARD'] },
    HAZARD: { up: ['GROUND'], down: ['GROUND'], left: ['GROUND'], right: ['GROUND'] },
    OBSTACLE: { up: ['GROUND'], down: ['GROUND'], left: ['GROUND'], right: ['GROUND'] }
};

export const volcanicTiles = createBiomeTileSet(
    VOLCANIC_TILE_TYPES,
    VOLCANIC_TILE_PROPERTIES,
    VOLCANIC_GROUPS,
    VOLCANIC_RULES
);




// wfc.js

/**
 * Í∞ÄÏ§ëÏπò Í≥ÑÏÇ∞ (tiles.js Îç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò)
 */
function buildTileWeights(tileSet) {
    const weights = {};

    for (const tile of Object.values(tileSet.TILE_TYPES)) {
        const prop = tileSet.TILE_PROPERTIES[tile];
        let weight = prop?.baseWeight ?? 1;

        if (prop?.weightModifiers?.multiplier) {
            weight *= prop.weightModifiers.multiplier;
        }

        weights[tile] = Math.max(0.01, weight);
    }

    return weights;
}

/**
 * Weighted random choice
 */
function weightedRandom(options, weights) {
    let total = 0;
    for (const o of options) total += weights[o] ?? 1;

    let r = Math.random() * total;
    for (const o of options) {
        r -= weights[o] ?? 1;
        if (r <= 0) return o;
    }
    return options[0];
}

/**
 * Shannon entropy
 */
function entropy(options, weights) {
    let sum = 0;
    let sumLog = 0;

    for (const o of options) {
        const w = weights[o] ?? 1;
        sum += w;
        sumLog += w * Math.log(w);
    }

    return Math.log(sum) - (sumLog / sum);
}

/**
 * WFC MAP GENERATION
 */
export function generateWfcMap(width, height, tileSet) {
    const TILE_WEIGHTS = buildTileWeights(tileSet);
    const ALL_TILES = Object.values(tileSet.TILE_TYPES);

    function initGrid() {
        return Array.from({ length: height }, (_, y) =>
            Array.from({ length: width }, (_, x) => ({
                x, y,
                collapsed: false,
                options: [...ALL_TILES]
            }))
        );
    }

    function lowestEntropyCells(grid) {
        let min = Infinity;
        let result = [];

        for (const row of grid) {
            for (const cell of row) {
                if (cell.collapsed || cell.options.length === 0) continue;
                const e = entropy(cell.options, TILE_WEIGHTS);
                if (e < min) {
                    min = e;
                    result = [cell];
                } else if (e === min) {
                    result.push(cell);
                }
            }
        }
        return result;
    }

    function propagate(start, grid) {
        const stack = [start];
        const w = width;
        const h = height;

        while (stack.length) {
            const cell = stack.pop();
            const { x, y } = cell;

            const dirs = [
                { dx: 0, dy: -1, dir: 'down' },
                { dx: 1, dy: 0, dir: 'left' },
                { dx: 0, dy: 1, dir: 'up' },
                { dx: -1, dy: 0, dir: 'right' }
            ];

            for (const { dx, dy, dir } of dirs) {
                const nx = x + dx;
                const ny = y + dy;
                if (nx < 0 || ny < 0 || nx >= w || ny >= h) continue;

                const n = grid[ny][nx];
                if (n.collapsed) continue;

                const before = n.options.length;

                n.options = n.options.filter(opt =>
                    cell.options.some(cOpt => {
                        const rules = tileSet.ADJACENCY_RULES[cOpt]?.[dir];
                        if (!rules) return true;
                        return rules.includes(opt);
                    })
                );

                if (n.options.length < before) {
                    stack.push(n);
                }
            }
        }
    }

    let attempts = 0;

    while (attempts < 10) {
        const grid = initGrid();
        let done = 0;

        while (done < width * height) {
            const candidates = lowestEntropyCells(grid);
            if (!candidates.length) break;

            const cell = candidates[Math.floor(Math.random() * candidates.length)];
            const choice = weightedRandom(cell.options, TILE_WEIGHTS);

            cell.options = [choice];
            cell.collapsed = true;
            done++;

            propagate(cell, grid);
        }

        if (done === width * height) {
            return grid.map(row =>
                row.map(cell => ({ name: cell.options[0] }))
            );
        }

        attempts++;
    }

    console.error('WFC failed: check adjacency rules or weights');
    return null;
}




*** Ïù¥Î†áÍ≤å tiles.jsÏôÄ wfc.jsÎ•º ÏàòÏ†ïÌïòÎ†§Í≥† Í∏∞ÌöçÌï¥Î¥§ÎäîÎç∞ ÎÑàÎäî Ïñ¥ÎñªÍ≤å ÏÉùÍ∞ÅÌïòÎäîÏßÄ ÏùòÍ≤¨ÏùÑ Ï†úÏãúÌï¥ÏÑú ÎÇ¥Í≤å ÏïåÎ†§Ï§òÎ¥ê
Í∏∞Ï°¥Ïùò ÏΩîÎìúÎ≥¥Îã§ Ïñ¥Îñ§ Ï†êÏù¥ Ï¢ãÏùÄÏßÄ Ïñ¥Îñ§ Ï†êÏù¥ ÎÇòÏÅ† Ïàò ÏûàÎäîÏßÄÎèÑ ÏÉùÍ∞ÅÌï¥ÏÑú ÏïåÎ†§Ï§ò